**My reflection was written by myself but in some parts (reflection for chapter 3) and big paragraph of my personal reflection I asked AI to help me better rephrase my words. The points and conclusion are the same but the final reflection.md has better grammar and phrasing:**

Original notes: <br>
(Ch 3 reflection) <br>
The reason why I decided to not split validateAndParse into two smaller methods was due to the class already having so many helper methods. The process of validating and parsing was already broken down into smaller parts where each method had one mission. Breaking down the wrapper method just to follow the rule of “single responsibility” actually makes it harder to grasp the whole code as a concept or understanding it if one wants to understand it on a deeper level than just an abstract one. It would require a lot of scrolling up and down to see the code and logic of each called method.

(Reflection - My own code quality) <br>
Looking back, my code quality improved significantly as I applied Clean Code principles. Early versions of my code had unclear variable names, redundant method calls, and functions that tried to do too much. Although I do find these early steps crucial. When I first try to tackle how to solve a problem and code it, trying to focus on making the code clean prevents me from making progress in the code. Most of my code was all written in one single function and after I made sure the logic was correct I would refactor after the clean code principles and it improved the readability and understandability. This also helped me in the long run, whenever I would go back to my code, it was easier to remember my past thought process or how I had envisioned the problem solving. In this specific assignment I was working with the Shunting Yard algorithm and to solve and convert the expressions, it takes a lot of control statements as many things have to get validated and checked for correct outcome. Many times when I tried to code this, I would get lost in the thought process and get overwhelmed because I had to think about the next step in the code that needed to be implemented. Along the way, I got better at refactoring while coding and this helped me tremendously. While I coded I could tell which smaller methods were needed. For example sometimes I had not actually figured out the logic on how to solve certain problems but I knew what needed to be done. For example toPostFix I knew I had to check each token and knew I had to handle numbers and operators separately but also needed to check for precedent between different operators. When I coded my initial draft of this function I knew I needed methods to handle these things before I worried about how to actually code them. Through refactoring, I made my code not only easier to read and understand but also to test. Dividing each part into smaller methods and having unit tests for each step of the process, made it easier for me to know where the problem was, to debug and fix. 
While also trying to follow the principle of DRY it actually saved me a lot of time. When I noticed I had code that would repeat itself, or a code I had I knew I needed several more times such as isOperator and isNumber, I would make a helper method that I could import and reuse in different classes,
I think my current code is the most clean I have written code before and is a project I believe I can look back on and still understand how it works compared to previous assignments I’ve written and dread looking back on. There are definitely parts I find could be improved to better follow the principles of Clean Code but like I previously reasoned, I believe following these guidelines is definitely beneficial but should not be followed strictly just because you “have to”. Making smaller methods is only needed when it increases clarity and removes duplication. Trying to have as small as possible functions with few lines of code isn’t always the best for readability or understandability. Sometimes I find that code that is longer but has clear steps and intentions of the thought process behind it, better. for example with many if and for loops make me understand the code better than a short and concise line of code (often codes that use short arrow functions with the help of filter, map etc that assumes I can think and view the whole process of what these methods do in my head compared to actually visually seeing a whole for loop instead of filter)
The thing I have learnt and stuck with me the most was the idea of “comments are often good method/function names”. I have a tendency to overexplain myself in my comments and I realised that many times, instead of explaining my code with comments I could make a new function that actually explains and communicates what my code does. 
I have also learnt that sometimes, the rule of not having overlapping names can not be avoided. Such as results or words that are common in different control scopes. But I still tried to implement them this time, instead of using result multiple times I tried to specify what type of result it was to not confuse the reader. 


(Reflection - Personal development) <br>
While this isn't directly related to clean code, I do want to mention in my reflection that working on clean code in this assignment also helped my imposter syndrome a lot. In previous assignments in my first year, many times I felt like I relied heavily on AI for help. Even if many of us try to use it as a helping tool it is very easy to become heavily reliant on it. Getting to work on a project that didn’t have focus on needing specific requirements but was my own choice of module to code but also having to code without generative ai was very helpful and made me realize I can code much more than I think. Along the way I also realized where a lot of my imposter syndrome came from. Often I get beat down by the thought of not being able to solve every problem by myself. But along the way of working on this assignment, I learnt about the shunting yard algorithm, and the use of stack for my evaluator. Many concepts and algorithms are well known and I am not expected to find the solutions to every problem from scratch. When I learnt about the shunting yard algorithm I realized I could never have come up with it myself, learning how it works is one thing I needed help with but how to actually implement and translate it to code was something I coded by myself from scratch. Having to focus on clean code principles and breaking everything into smaller methods also helped me actually solve the problem while coding. A lot of complex problems are actually just a bunch of smaller problems and can be broken down into small methods that solve or check these control statements. At first I decided to not implement support for parenthesis as I felt it would be too difficult while I was already struggling to know how to handle support for PEMDAS. Now when I am done, I can see myself being able to implement this afterwards. It really doesn’t require more complexity, just a lot more control statements and code and a problem I need to break down into smaller methods. In validation I would need to check for parenthesis, change the rules for the expression format (allowing the beginning of a parenthesis but also which specific one. If I have a parenthesis what is allowed before or after it, I must have it closed etc.)
